{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AGON","text":"<p>Adaptive Guarded Object Notation \u2014 Self-describing, token-efficient JSON encodings optimized for LLM prompts.</p>"},{"location":"#what-is-agon","title":"What is AGON?","text":"<p>AGON is an adaptive encoding library for Python that automatically selects the most token-efficient format for your data\u2014guaranteed to never be worse than compact JSON. It provides multiple specialized encoding formats that can reduce token usage by 30-60% compared to JSON, while maintaining perfect lossless round-trip conversion.</p>"},{"location":"#the-problem","title":"The Problem","text":"<p>Fixed-format encoders can actually make token counts worse. When your data doesn't match the encoder's assumptions (deeply nested objects, sparse arrays, irregular structures), you pay the overhead of the format without the benefits.</p>"},{"location":"#agons-solution","title":"AGON's Solution","text":"<p>Adaptive encoding with safety guarantees:</p> <pre><code>result = AGON.encode(data, format=\"auto\")\n# Auto tries: text, columns, struct\n# Returns: whichever saves the most tokens\n# Falls back: to compact JSON if none are better\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Here's AGON in action with a simple user list:</p> Python CodeAGONText OutputToken Comparison <pre><code>from agon import AGON\n\n# Sample data - list of objects with repeated structure\ndata = [\n    {\"id\": 1, \"name\": \"Alice\", \"role\": \"admin\"},\n    {\"id\": 2, \"name\": \"Bob\", \"role\": \"user\"},\n    {\"id\": 3, \"name\": \"Charlie\", \"role\": \"user\"},\n]\n\n# Encode with auto-selection\nresult = AGON.encode(data, format=\"auto\")\nprint(f\"Selected format: {result.format}\")  # \u2192 \"text\"\n\n# Use directly in LLM prompts\nprompt = f\"\"\"Analyze this user data:\n\n{result}\n\nWhat percentage are admins?\"\"\"\n\n# Verify lossless round-trip\ndecoded = AGON.decode(result)\nassert decoded == data  # Perfect reconstruction\n</code></pre> <pre><code>[3]{id  name    role}\n1   Alice   admin\n2   Bob user\n3   Charlie user\n</code></pre> <p>Clean, tab-delimited format with array length <code>[3]</code> and field headers <code>{id name role}</code>. No <code>@AGON</code> header needed when sending to LLMs\u2014only required for decoding.</p> Format Tokens Savings Pretty JSON 62 baseline Compact JSON 37 +40% AGON Text 26 +58% <p>AGON's adaptive selection identified that this uniform array is ideal for AGONText format, achieving 58% token savings compared to pretty JSON, and 30% savings even against compact JSON.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install AGON via pip:</p> <pre><code>pip install agon-python\n</code></pre> <p>Or using uv (recommended):</p> <pre><code>uv add agon-python\n</code></pre>"},{"location":"#how-it-works","title":"How It Works","text":"<p>AGON provides three specialized formats, each optimized for different data shapes:</p>"},{"location":"#1-agontext-row-based-encoding","title":"1. AGONText - Row-Based Encoding","text":"<p>Best for uniform arrays of objects with consistent fields.</p> <pre><code>[3]{id  name    role}\n1   Alice   admin\n2   Bob user\n3   Charlie user\n</code></pre> <p>Ideal for: User lists, transaction logs, simple metrics Token savings: 40-60% vs pretty JSON</p>"},{"location":"#2-agoncolumns-columnar-encoding","title":"2. AGONColumns - Columnar Encoding","text":"<p>Best for wide tables (many columns) or numeric-heavy data.</p> <pre><code>users[3]\n\u251c id: 1 2   3\n\u251c name: Alice   Bob Charlie\n\u2514 role: admin   user    user\n</code></pre> <p>Ideal for: Financial data (20+ fields), analytics tables Token savings: 50-70% vs pretty JSON</p>"},{"location":"#3-agonstruct-template-based-encoding","title":"3. AGONStruct - Template-Based Encoding","text":"<p>Best for repeated nested patterns like <code>{fmt, raw}</code> or <code>{value, timestamp}</code>.</p> <pre><code>@FR: fmt, raw\n\nprice: FR(\"$100.00\", 100.0)\nchange: FR(\"+5.00\", 5.0)\n</code></pre> <p>Ideal for: Market data, API responses with nested structures Token savings: 30-50% vs pretty JSON</p>"},{"location":"#adaptive-auto-mode","title":"Adaptive Auto Mode","text":"<p>The <code>format=\"auto\"</code> mode tries all three formats and selects the winner:</p> <p><code>mermaid graph TD     A[Encode data with auto mode] --&gt; B[Try AGONText]     A --&gt; C[Try AGONColumns]     A --&gt; D[Try AGONStruct]     A --&gt; E[Compact JSON baseline]     B --&gt; F[Count tokens]     C --&gt; F     D --&gt; F     E --&gt; F     F --&gt; G{Best format saves \u226510%&lt;br/&gt;vs JSON?}     G --&gt;|Yes| H[Return best format]     G --&gt;|No| I[Return JSON]     H --&gt; J[Token-efficient AGON]     I --&gt; K[Safe JSON fallback]</code></p>"},{"location":"#why-not-just-use-a-fixed-format","title":"Why Not Just Use a Fixed Format?","text":"<p>The Fixed-Format Problem</p> <p>Fixed-format encoders like TOON can be worse than JSON on irregular data:</p> <pre><code># Fixed format: Always applies encoding\ntoon_result = TOON.encode(complex_data)  # Might be worse than JSON!\n\n# AGON: Adaptive with safety guarantee\nagon_result = AGON.encode(complex_data, format=\"auto\")  # Never worse than JSON\n</code></pre> <p>AGON's auto mode guarantees you'll never regret using it. If specialized formats don't save enough tokens, it returns compact JSON</p> <p>AGON vs TOON</p> <p>AGON and TOON are complementary:</p> <ul> <li>TOON: Single unified format, predictable encoding, great for uniform arrays</li> <li>AGON: Multiple adaptive formats + JSON fallback, best format per data shape</li> </ul> <p>For uniform arrays, <code>AGONText</code> produces identical output to TOON. For everything else, AGON's adaptive approach ensures you always get the best result.</p>"},{"location":"#community-contributing","title":"Community &amp; Contributing","text":"<p>AGON is open source and welcomes contributions!</p> <ul> <li>Report issues</li> <li>Request features</li> <li>Contribute</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE for details.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete reference for all AGON methods and classes.</p>"},{"location":"api/#agon-class","title":"AGON Class","text":"<p>The main entry point for encoding and decoding operations.</p>"},{"location":"api/#agonencode","title":"AGON.encode()","text":"<p>Encode data to the optimal token-efficient format.</p> <p>Signature:</p> <pre><code>AGON.encode(\n    data: object,\n    format: Format = \"auto\",\n    force: bool = False,\n    min_savings: float = 0.10,\n    encoding: str = \"o200k_base\"\n) -&gt; AGONEncoding\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>data</code> <code>object</code> required JSON-serializable Python data to encode <code>format</code> <code>Format</code> <code>\"auto\"</code> Format to use: <code>\"auto\"</code>, <code>\"json\"</code>, <code>\"text\"</code>, <code>\"columns\"</code>, <code>\"struct\"</code> <code>force</code> <code>bool</code> <code>False</code> If True with <code>format=\"auto\"</code>, never fall back to JSON <code>min_savings</code> <code>float</code> <code>0.10</code> Minimum token savings (0.0-1.0) required to use specialized format vs JSON <code>encoding</code> <code>str</code> <code>\"o200k_base\"</code> Token encoding to use for counting (tiktoken encoding name) <p>Returns: <code>AGONEncoding</code> - Result object with encoded text and metadata</p> <p>Examples:</p> Auto Selection (Recommended)Specific FormatCustom ThresholdForce Specialized Format <pre><code>from agon import AGON\n\ndata = [\n    {\"id\": 1, \"name\": \"Alice\", \"role\": \"admin\"},\n    {\"id\": 2, \"name\": \"Bob\", \"role\": \"user\"},\n]\n\n# Auto-select best format\nresult = AGON.encode(data, format=\"auto\")\nprint(f\"Selected: {result.format}\")  # \u2192 \"text\"\nprint(f\"Tokens: {AGON.count_tokens(result.text)}\")\nprint(result)  # Use directly in LLM prompts\n</code></pre> <pre><code># Force a specific format\nresult_text = AGON.encode(data, format=\"text\")\nresult_columns = AGON.encode(data, format=\"columns\")\nresult_struct = AGON.encode(data, format=\"struct\")\nresult_json = AGON.encode(data, format=\"json\")\n\n# Each returns AGONEncoding with the specified format\n</code></pre> <pre><code># Require 20% savings before using specialized format\nresult = AGON.encode(data, format=\"auto\", min_savings=0.20)\n\n# Lower threshold for aggressive optimization\nresult = AGON.encode(data, format=\"auto\", min_savings=0.05)\n</code></pre> <pre><code># Never fall back to JSON, always use best specialized format\nresult = AGON.encode(data, format=\"auto\", force=True)\n\n# Useful when you know your data is structured\n# and want maximum token savings\n</code></pre>"},{"location":"api/#agondecode","title":"AGON.decode()","text":"<p>Decode AGON-encoded data back to original Python objects.</p> <p>Signatures:</p> <pre><code># Overload 1: Decode AGONEncoding result\nAGON.decode(payload: AGONEncoding) -&gt; object\n\n# Overload 2: Decode string with auto-detection\nAGON.decode(payload: str, format: ConcreteFormat | None = None) -&gt; object\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>payload</code> <code>AGONEncoding \\| str</code> required Encoded data to decode <code>format</code> <code>ConcreteFormat \\| None</code> <code>None</code> Optional format override (<code>\"json\"</code>, <code>\"text\"</code>, <code>\"columns\"</code>, <code>\"struct\"</code>) <p>Returns: <code>object</code> - Decoded Python data (list, dict, etc.)</p> <p>Examples:</p> Round-Trip DecodeAuto-Detect from HeaderExplicit Format <pre><code>data = [{\"id\": 1, \"name\": \"Alice\"}]\n\n# Encode\nresult = AGON.encode(data, format=\"text\")\n\n# Decode - automatically uses result's format\ndecoded = AGON.decode(result)\nassert decoded == data  # Lossless\n</code></pre> <pre><code># AGON-encoded string with header\nagon_string = \"\"\"@AGON text\n\n[2]{id  name}\n1   Alice\n2   Bob\"\"\"\n\n# Auto-detects \"text\" format from @AGON header\ndecoded = AGON.decode(agon_string)\n# \u2192 [{\"id\": 1, \"name\": \"Alice\"}, {\"id\": 2, \"name\": \"Bob\"}]\n</code></pre> <pre><code># Decode without header by specifying format\nagon_text_without_header = \"\"\"[2]{id    name}\n1   Alice\n2   Bob\"\"\"\n\ndecoded = AGON.decode(agon_text_without_header, format=\"text\")\n# \u2192 [{\"id\": 1, \"name\": \"Alice\"}, {\"id\": 2, \"name\": \"Bob\"}]\n</code></pre>"},{"location":"api/#agonproject_data","title":"AGON.project_data()","text":"<p>Filter data to keep only specific fields, supporting dotted paths for nested access.</p> <p>Signature:</p> <pre><code>AGON.project_data(\n    data: list[dict],\n    keep_paths: list[str]\n) -&gt; list[dict]\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>data</code> <code>list[dict]</code> List of dictionaries to filter <code>keep_paths</code> <code>list[str]</code> List of field paths to keep (supports dot notation) <p>Returns: <code>list[dict]</code> - Filtered data with only specified fields</p> <p>Examples:</p> Simple FieldsNested PathsArray Fields <pre><code>data = [\n    {\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\", \"age\": 28},\n    {\"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\", \"age\": 32},\n]\n\n# Keep only id and name\nprojected = AGON.project_data(data, [\"id\", \"name\"])\n# \u2192 [{\"id\": 1, \"name\": \"Alice\"}, {\"id\": 2, \"name\": \"Bob\"}]\n</code></pre> <pre><code>data = [\n    {\n        \"user\": {\n            \"profile\": {\"name\": \"Alice\", \"age\": 28},\n            \"settings\": {\"theme\": \"dark\"}\n        },\n        \"status\": \"active\"\n    }\n]\n\n# Extract nested fields with dot notation\nprojected = AGON.project_data(data, [\"user.profile.name\", \"status\"])\n# \u2192 [{\"user\": {\"profile\": {\"name\": \"Alice\"}}, \"status\": \"active\"}]\n</code></pre> <pre><code>data = [\n    {\n        \"type\": \"DAY_GAINERS\",\n        \"quotes\": [\n            {\"symbol\": \"AAPL\", \"price\": 150.0, \"volume\": 1000000},\n            {\"symbol\": \"GOOGL\", \"price\": 2800.0, \"volume\": 500000}\n        ]\n    }\n]\n\n# Project fields from nested arrays\nprojected = AGON.project_data(data, [\"quotes.symbol\", \"quotes.price\"])\n# \u2192 [{\"quotes\": [{\"symbol\": \"AAPL\", \"price\": 150.0},\n#                {\"symbol\": \"GOOGL\", \"price\": 2800.0}]}]\n</code></pre> <p>Use Before Encoding</p> <p>Project data before encoding to reduce token count further:</p> <pre><code># Filter to essential fields, then encode\nprojected = AGON.project_data(full_data, [\"id\", \"name\", \"score\"])\nresult = AGON.encode(projected, format=\"auto\")\n</code></pre>"},{"location":"api/#agonhint","title":"AGON.hint()","text":"<p>Get prescriptive generation instructions for LLMs (experimental feature for asking LLMs to return AGON-formatted data).</p> <p>Signature:</p> <pre><code>AGON.hint(\n    result_or_format: AGONEncoding | ConcreteFormat\n) -&gt; str\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>result_or_format</code> <code>AGONEncoding \\| ConcreteFormat</code> Encoding result or format name (<code>\"text\"</code>, <code>\"columns\"</code>, <code>\"struct\"</code>, <code>\"json\"</code>) <p>Returns: <code>str</code> - Prescriptive hint instructing how to generate the format</p> <p>Examples:</p> From Encoding ResultFrom Format NameUse in LLM Prompts <pre><code>data = [{\"id\": 1, \"name\": \"Alice\"}]\nresult = AGON.encode(data, format=\"auto\")\n\n# Get hint for the selected format\nhint = AGON.hint(result)\nprint(hint)\n# \u2192 \"Return in AGON text format: Start with @AGON text header,\n#    encode arrays as name[N]{fields} with tab-delimited rows\"\n</code></pre> <pre><code># Get hint for specific format\nhint_text = AGON.hint(\"text\")\nhint_columns = AGON.hint(\"columns\")\nhint_struct = AGON.hint(\"struct\")\n</code></pre> <pre><code>data = [{\"id\": 1, \"name\": \"Alice\", \"role\": \"admin\"}]\nresult = AGON.encode(data, format=\"auto\")\n\n# Ask LLM to respond in AGON format\nprompt = f\"\"\"Analyze this data and return enriched results in AGON format.\n\nInstructions: {AGON.hint(result)}\n\nExample output:\n{result.with_header()}\n\nTask: Add a \"seniority\" field (junior/mid/senior) based on role.\n\"\"\"\n</code></pre> <p>Experimental Feature</p> <p>LLMs have not been trained on AGON format, so generation accuracy cannot be guaranteed. This is experimental\u2014always validate LLM-generated AGON data.</p> <p>Prefer: Sending AGON to LLMs (reliable) Over: Asking LLMs to generate AGON (experimental)</p>"},{"location":"api/#agoncount_tokens","title":"AGON.count_tokens()","text":"<p>Count tokens in text using the specified encoding.</p> <p>Signature:</p> <pre><code>AGON.count_tokens(\n    text: str,\n    encoding: str = \"o200k_base\"\n) -&gt; int\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>text</code> <code>str</code> required Text to count tokens for <code>encoding</code> <code>str</code> <code>\"o200k_base\"</code> Tiktoken encoding name <p>Returns: <code>int</code> - Number of tokens</p> <p>Example:</p> <pre><code>text = \"Hello, world!\"\ntokens = AGON.count_tokens(text)\nprint(f\"Tokens: {tokens}\")  # \u2192 4\n\n# Use different encoding\ntokens_gpt4 = AGON.count_tokens(text, encoding=\"cl100k_base\")\n</code></pre>"},{"location":"api/#agonencoding-class","title":"AGONEncoding Class","text":"<p>Result object returned by <code>AGON.encode()</code>.</p> <p>Attributes:</p> Attribute Type Description <code>format</code> <code>ConcreteFormat</code> Format used: <code>\"json\"</code>, <code>\"text\"</code>, <code>\"columns\"</code>, <code>\"struct\"</code> <code>text</code> <code>str</code> Encoded output (ready for LLM prompts) <code>header</code> <code>str</code> Format header (e.g., <code>\"@AGON text\"</code>) <p>Methods:</p>"},{"location":"api/#__str__","title":"__str__()","text":"<p>Returns the encoded text (without header) for direct use in prompts.</p> <pre><code>result = AGON.encode(data, format=\"text\")\nprompt = f\"Analyze this data:\\n\\n{result}\"  # Converts to string via __str__()\n</code></pre>"},{"location":"api/#__len__","title":"__len__()","text":"<p>Returns character count of the encoded text.</p> <pre><code>result = AGON.encode(data, format=\"text\")\nchar_count = len(result)  # Character count\n</code></pre>"},{"location":"api/#__repr__","title":"__repr__()","text":"<p>Returns debug representation.</p> <pre><code>result = AGON.encode(data, format=\"text\")\nprint(repr(result))\n# \u2192 AGONEncoding(format='text', length=45)\n</code></pre>"},{"location":"api/#with_header","title":"with_header()","text":"<p>Returns encoded text with header prepended (for auto-detect decoding).</p> <pre><code>result = AGON.encode(data, format=\"text\")\n\n# Without header (for sending to LLM)\nprint(result.text)\n# \u2192 [2]{id  name}\n#   1   Alice\n#   2   Bob\n\n# With header (for decoding)\nprint(result.with_header())\n# \u2192 @AGON text\n#\n#   [2]{id  name}\n#   1   Alice\n#   2   Bob\n</code></pre> <p>Use cases:</p> <ul> <li>Without header (<code>result.text</code> or <code>str(result)</code>): Send to LLM prompts</li> <li>With header (<code>result.with_header()</code>): Store for later decoding, or ask LLM to return in same format</li> </ul>"},{"location":"api/#format-specific-encoders","title":"Format-Specific Encoders","text":"<p>For advanced use cases, you can access format-specific encoders directly.</p>"},{"location":"api/#agontext","title":"AGONText","text":"<pre><code>from agon.formats import AGONText\n\n# Direct encoding with custom options\nencoded = AGONText.encode(\n    data,\n    delimiter=\"\\t\",  # Default: tab\n    include_header=False  # Default: False\n)\n\n# Direct decoding\ndecoded = AGONText.decode(encoded)\n</code></pre>"},{"location":"api/#agoncolumns","title":"AGONColumns","text":"<pre><code>from agon.formats import AGONColumns\n\n# Direct encoding\nencoded = AGONColumns.encode(\n    data,\n    delimiter=\"\\t\",  # Default: tab\n    include_header=False\n)\n\ndecoded = AGONColumns.decode(encoded)\n</code></pre>"},{"location":"api/#agonstruct","title":"AGONStruct","text":"<pre><code>from agon.formats import AGONStruct\n\n# Direct encoding\nencoded = AGONStruct.encode(\n    data,\n    include_header=False\n)\n\ndecoded = AGONStruct.decode(encoded)\n</code></pre> <p>When to Use Direct Encoders</p> <p>Use direct format encoders when:</p> <ul> <li>You want guaranteed format selection (bypass auto mode)</li> <li>You need format-specific options (custom delimiters)</li> <li>You're benchmarking or comparing formats</li> </ul> <p>For most use cases, <code>AGON.encode(data, format=\"text\")</code> is preferred.</p>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>AGON defines a hierarchy of exceptions for error handling.</p>"},{"location":"api/#agonerror","title":"AGONError","text":"<p>Base exception for all AGON errors.</p> <pre><code>from agon import AGONError\n\ntry:\n    result = AGON.encode(data, format=\"auto\")\nexcept AGONError as e:\n    print(f\"AGON error: {e}\")\n</code></pre>"},{"location":"api/#format-specific-exceptions","title":"Format-Specific Exceptions","text":"<ul> <li><code>AGONTextError</code> - Errors specific to AGONText format</li> <li><code>AGONColumnsError</code> - Errors specific to AGONColumns format</li> <li><code>AGONStructError</code> - Errors specific to AGONStruct format</li> </ul> <pre><code>from agon import AGONTextError, AGONColumnsError, AGONStructError\n\ntry:\n    result = AGON.decode(malformed_agon_text, format=\"text\")\nexcept AGONTextError as e:\n    print(f\"Text format error: {e}\")\n</code></pre>"},{"location":"api/#constants-defaults","title":"Constants &amp; Defaults","text":"Constant Value Description <code>DEFAULT_ENCODING</code> <code>\"o200k_base\"</code> Default token encoding (GPT-4, GPT-4 Turbo) <code>DEFAULT_DELIMITER</code> <code>\"\\t\"</code> Default field delimiter (tab character) <code>DEFAULT_MIN_SAVINGS</code> <code>0.10</code> Default minimum token savings threshold (10%)"},{"location":"api/#type-aliases","title":"Type Aliases","text":"<pre><code>from agon import Format, ConcreteFormat\n\n# Format includes \"auto\"\nFormat = Literal[\"auto\", \"json\", \"text\", \"columns\", \"struct\"]\n\n# ConcreteFormat excludes \"auto\" (actual encoding formats)\nConcreteFormat = Literal[\"json\", \"text\", \"columns\", \"struct\"]\n</code></pre>"},{"location":"api/#next-steps","title":"Next Steps","text":""},{"location":"api/#json-fallback","title":"JSON Fallback","text":"<p>View how JSON is used as a safety net</p>"},{"location":"api/#agontext-format","title":"AGONText Format","text":"<p>Complete guide to row-based encoding</p>"},{"location":"api/#core-concepts","title":"Core Concepts","text":"<p>Understand AGON's adaptive approach and design principles</p>"},{"location":"api/#benchmarks","title":"Benchmarks","text":"<p>See real-world performance across multiple datasets</p>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>Real-world performance data demonstrating AGON's adaptive format selection and token savings.</p>"},{"location":"benchmarks/#overview","title":"Overview","text":"<p>These benchmarks measure token counts across 6 real-world datasets using tiktoken's <code>o200k_base</code> encoding (GPT-4, GPT-4 Turbo, GPT-4o). All results are reproducible\u2014run <code>uv run pytest tests/test_benchmarks.py -v</code> to verify.</p>"},{"location":"benchmarks/#benchmark-datasets","title":"Benchmark Datasets","text":"Dataset Size Description Characteristics toon.json 665 bytes Hiking records with nested context Uniform array (3 records, 6 fields), mixed nesting 128KB.json 255 KB Large structured data Many nested arrays, wide tables chart.json 201 KB Chart.js configuration Deep nesting, array-heavy, metadata objects gainers.json 263 KB Market gainers (100 quotes) Complex irregular nested objects (20+ fields each) scars.json 10 KB Error tracking data Mixed structure, heterogeneous fields historical.json 130 KB Historical time-series data Repeated <code>{time, value}</code> pattern (struct candidate)"},{"location":"benchmarks/#results-summary","title":"Results Summary","text":"Dataset Pretty JSON Compact JSON AGONText AGONColumns AGONStruct Auto Selected Savings toon.json 229 139 96 108 130 text (96) +58.1% 128KB.json 77,346 63,230 54,622 54,292 56,772 columns (54,292) +29.8% chart.json 101,767 71,802 51,541 51,558 61,595 text (51,541) +49.4% gainers.json 142,791 91,634 113,132 113,132 89,011 json (91,634) +35.8% scars.json 2,600 2,144 2,225 2,230 2,437 json (2,144) +17.5% historical.json 84,094 55,228 70,286 70,286 47,713 struct (47,713) +43.3% <p>Safety Net Demonstrated</p> <p>gainers.json and scars.json show auto mode's safety guarantee in action:</p> <ul> <li>Text/Columns formats made token counts worse than compact JSON (113K vs 91K for gainers)</li> <li>Auto mode correctly fell back to JSON, avoiding regression</li> <li>Auto selection uses the compact-JSON baseline for <code>min_savings</code> gating (see AGON.encode), so <code>gainers.json</code> chose JSON even though savings against pretty JSON are high.</li> </ul>"},{"location":"benchmarks/#savings","title":"Savings","text":""},{"location":"benchmarks/#running-benchmarks","title":"Running Benchmarks","text":"<p>Reproduce these results locally:</p> <pre><code># Run all benchmarks with verbose output\nuv run pytest tests/test_benchmarks.py -v\n\n# Run benchmarks for specific dataset\nuv run pytest tests/test_benchmarks.py::test_benchmark_toon -v\n</code></pre>"},{"location":"benchmarks/#methodology","title":"Methodology","text":""},{"location":"benchmarks/#token-counting","title":"Token Counting","text":"<p>All token counts use <code>tiktoken</code> library with <code>o200k_base</code> encoding:</p> <pre><code>import tiktoken\n\nencoding = tiktoken.get_encoding(\"o200k_base\")\ntokens = len(encoding.encode(text))\n</code></pre> <p>This encoding is used by:</p> <ul> <li>GPT-4 (all variants)</li> <li>GPT-4 Turbo</li> <li>GPT-4o</li> </ul>"},{"location":"benchmarks/#baseline-comparison","title":"Baseline Comparison","text":"<p>Pretty JSON: <code>json.dumps(data, indent=2)</code></p> <ul> <li>Standard 2-space indentation</li> <li>Newlines after each field</li> <li>Human-readable, not optimized</li> </ul> <p>Compact JSON: <code>json.dumps(data, separators=(',', ':'))</code></p> <ul> <li>No whitespace</li> <li>Minimal formatting</li> <li>Primary baseline for AGON <code>min_savings</code> comparison</li> </ul>"},{"location":"benchmarks/#format-testing","title":"Format Testing","text":"<p>Each dataset tested with all formats:</p> <ol> <li>AGONText: Row-based tabular encoding</li> <li>AGONColumns: Columnar transpose encoding</li> <li>AGONStruct: Template-based encoding</li> <li>Auto mode: Selects best of above or falls back to JSON</li> </ol>"},{"location":"benchmarks/#savings-calculation","title":"Savings Calculation","text":"<pre><code>savings_percent = ((baseline - agon) / baseline) * 100\n</code></pre> <ul> <li>Positive %: AGON saved tokens (better)</li> <li>Negative %: AGON used more tokens (worse\u2014triggers JSON fallback)</li> </ul>"},{"location":"benchmarks/#next-steps","title":"Next Steps","text":""},{"location":"benchmarks/#json-fallback","title":"JSON Fallback","text":"<p>View how JSON is used as a safety net</p>"},{"location":"benchmarks/#agontext-format","title":"AGONText Format","text":"<p>Learn about the most common format</p>"},{"location":"benchmarks/#api-reference","title":"API Reference","text":"<p>Complete API documentation</p>"},{"location":"benchmarks/#core-concepts","title":"Core Concepts","text":"<p>Design principles and adaptive approach</p>"},{"location":"concepts/","title":"Core Concepts","text":"<p>Understanding AGON's adaptive approach and design principles.</p>"},{"location":"concepts/#the-adaptive-approach","title":"The Adaptive Approach","text":"<p>AGON's defining feature is adaptive format selection\u2014automatically choosing the most token-efficient encoding for your data while guaranteeing you'll never do worse than compact JSON.</p>"},{"location":"concepts/#how-auto-mode-works","title":"How Auto Mode Works","text":"<p>When you call <code>AGON.encode(data, format=\"auto\")</code>, here's what happens:</p> <p>```mermaid flowchart TD     A[Start: Encode data with auto mode]</p> <pre><code>A --&gt; B[Compact JSON baseline]\nA --&gt; C[AGONText format]\nA --&gt; D[AGONColumns format]\nA --&gt; E[AGONStruct format]\n\nB --&gt; F[Count tokens for all formats]\nC --&gt; F\nD --&gt; F\nE --&gt; F\n\nF --&gt; G{Find best format}\nG --&gt; H{Best saves \u2265 threshold&lt;br/&gt;vs JSON?}\nH --&gt;|Yes| I[Return best format]\nH --&gt;|No| J[Return JSON]\nI --&gt; K[Token-efficient AGON]\nJ --&gt; L[Safe JSON fallback]\n\nstyle A fill:#1976D2,color:#fff,stroke:#0D47A1,stroke-width:2px\nstyle K fill:#388E3C,color:#fff,stroke:#1B5E20,stroke-width:2px\nstyle L fill:#F57C00,color:#fff,stroke:#E65100,stroke-width:2px\n</code></pre> <p>```</p> <p>The 5-step process:</p> <ol> <li>Baseline: Encode data to compact JSON and count tokens</li> <li>Try specialized formats: Encode with AGONText, AGONColumns, and AGONStruct</li> <li>Measure: Count tokens for each specialized format</li> <li>Compare: Calculate savings percentage vs JSON baseline</li> <li>Decide:<ul> <li>If best format saves \u2265 threshold (default 10%), use it</li> <li>Otherwise, return compact JSON</li> </ul> </li> </ol> <p>The Guarantee</p> <p>Auto mode will never return a format with more tokens than compact JSON. You can use <code>format=\"auto\"</code> everywhere with confidence.</p>"},{"location":"concepts/#minimum-savings-threshold","title":"Minimum Savings Threshold","text":"<p>The threshold controls when AGON uses specialized formats vs falling back to JSON.</p>"},{"location":"concepts/#default-configuration","title":"Default Configuration","text":"<pre><code># Default: Require 10% token savings to use specialized format\nresult = AGON.encode(data, format=\"auto\")  # min_savings=0.10\n</code></pre>"},{"location":"concepts/#tuning-the-threshold","title":"Tuning the Threshold","text":"More Conservative (20%)More Aggressive (5%)Force Best Format <pre><code># Only use specialized formats for significant savings\nresult = AGON.encode(data, format=\"auto\", min_savings=0.20)\n</code></pre> <p>Use when:</p> <ul> <li>You want very high confidence in savings</li> <li>Format overhead is a concern</li> <li>You prefer simple JSON for marginal gains</li> </ul> <pre><code># Accept smaller savings\nresult = AGON.encode(data, format=\"auto\", min_savings=0.05)\n</code></pre> <p>Use when:</p> <ul> <li>Every token counts (high-volume applications)</li> <li>You trust the specialized formats</li> <li>You've validated on your data</li> </ul> <pre><code># Always use best specialized format, never JSON\nresult = AGON.encode(data, format=\"auto\", force=True)\n</code></pre> <p>Use when:</p> <ul> <li>You know your data is structured</li> <li>You want maximum savings</li> <li>You've validated format selection on representative data</li> </ul> <p>Threshold Recommendations</p> Threshold Conservative Recommended Use 0.05 (5%) Low High-volume, validated pipelines 0.10 (10%) Medium General purpose (default) 0.20 (20%) High Risk-averse, prefer simplicity"},{"location":"concepts/#the-three-specialized-formats","title":"The Three Specialized Formats","text":"<p>AGON provides three encoding formats, each optimized for different data shapes:</p>"},{"location":"concepts/#format-comparison","title":"Format Comparison","text":""},{"location":"concepts/#agontext","title":"AGONText","text":"<p>Row-based tabular encoding</p> <pre><code>[3]{id  name    role}\n1   Alice   admin\n2   Bob user\n3   Charlie user\n</code></pre> <p>Best for:</p> <ul> <li>Uniform arrays of objects</li> <li>Consistent field structure</li> <li>Transaction logs, user lists</li> <li>Simple metrics</li> </ul> <p>Token savings: 40-60% vs pretty JSON</p>"},{"location":"concepts/#agoncolumns","title":"AGONColumns","text":"<p>Columnar transpose encoding</p> <pre><code>users[3]\n\u251c id: 1 2   3\n\u251c name: Alice   Bob Charlie\n\u2514 role: admin   user    user\n</code></pre> <p>Best for:</p> <ul> <li>Wide tables (10+ columns)</li> <li>Numeric-heavy data</li> <li>Financial records</li> <li>Analytics tables</li> </ul> <p>Token savings: 50-70% vs pretty JSON</p>"},{"location":"concepts/#agonstruct","title":"AGONStruct","text":"<p>Template-based encoding</p> <pre><code>@FR: fmt, raw\n\nprice: FR(\"$100\", 100.0)\nchange: FR(\"+5\", 5.0)\n</code></pre> <p>Best for:</p> <ul> <li>Repeated nested patterns</li> <li>Market data (<code>{fmt, raw}</code>)</li> <li>Timestamps with values</li> <li>Complex API responses</li> </ul> <p>Token savings: 30-50% vs pretty JSON</p>"},{"location":"concepts/#format-selection-patterns","title":"Format Selection Patterns","text":"<p>Different data shapes naturally favor different formats:</p> Uniform Arrays \u2192 TextWide Tables \u2192 ColumnsNested Patterns \u2192 Struct <pre><code>data = [\n    {\"id\": 1, \"name\": \"Alice\", \"score\": 95},\n    {\"id\": 2, \"name\": \"Bob\", \"score\": 87},\n    {\"id\": 3, \"name\": \"Charlie\", \"score\": 92},\n]\n\nresult = AGON.encode(data, format=\"auto\")\n# \u2192 Selects \"text\" format\n#\n# [3]{id    name    score}\n# 1 Alice   95\n# 2 Bob 87\n# 3 Charlie 92\n</code></pre> <p>Why text wins: Consistent structure, few fields, perfect for row-based encoding.</p> <pre><code>data = [\n    {\n        \"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\",\n        \"age\": 28, \"city\": \"NYC\", \"state\": \"NY\", \"zip\": \"10001\",\n        \"phone\": \"555-0001\", \"dept\": \"Eng\", \"title\": \"SWE\",\n        \"salary\": 120000, \"start_date\": \"2020-01-15\"\n    },\n    # ... more records with same 12 fields\n]\n\nresult = AGON.encode(data, format=\"auto\")\n# \u2192 Selects \"columns\" format (transposes to group types)\n</code></pre> <p>Why columns wins: 10+ fields benefit from type clustering and vertical layout.</p> <pre><code>data = {\n    \"price\": {\"fmt\": \"$100.00\", \"raw\": 100.0},\n    \"change\": {\"fmt\": \"+5.00\", \"raw\": 5.0},\n    \"volume\": {\"fmt\": \"1.2M\", \"raw\": 1200000},\n    \"high\": {\"fmt\": \"$105.00\", \"raw\": 105.0},\n    \"low\": {\"fmt\": \"$98.50\", \"raw\": 98.5}\n}\n\nresult = AGON.encode(data, format=\"auto\")\n# \u2192 Selects \"struct\" format\n#\n# @FR: fmt, raw\n# price: FR(\"$100.00\", 100.0)\n# change: FR(\"+5.00\", 5.0)\n# ...\n</code></pre> <p>Why struct wins: Repeated <code>{fmt, raw}</code> pattern appears 5 times\u2014template amortizes over instances.</p>"},{"location":"concepts/#when-agon-falls-back-to-json","title":"When AGON Falls Back to JSON","text":"<p>Auto mode returns compact JSON when specialized formats don't provide enough benefit. This is a feature, not a failure.</p>"},{"location":"concepts/#example-complex-nested-data","title":"Example: Complex Nested Data","text":"<pre><code># gainers.json: 100 complex quote objects with deeply nested structures\ndata = load_json(\"gainers.json\")  # 100 quotes, each with 20+ fields, irregular nesting\n\nresult = AGON.encode(data, format=\"auto\")\nprint(result.format)  # \u2192 \"json\"\n</code></pre> <p>Token analysis:</p> Format Tokens Savings vs Pretty Savings vs Compact Pretty JSON 142,791 baseline -55.9% (worse) Compact JSON 91,634 +35.8% baseline AGONText 113,132 +20.8% -23.4% (worse) AGONColumns 113,132 +20.8% -23.4% (worse) AGONStruct 89,011 +37.7% +2.9% (below threshold) Auto Selection 91,634 +35.8% 0% (safe fallback) <p>Safety Net in Action</p> <p>Even though <code>struct</code> format achieved the best absolute savings (37.7% vs pretty JSON), when compared against compact JSON (the real alternative), it only saved 2.9%\u2014below the 10% minimum threshold.</p> <p>Auto mode correctly returned compact JSON, guaranteeing excellent performance (35.8% savings) with zero complexity and zero risk.</p> <p>Key insight: Text/columns formats actually hurt compared to compact JSON (113K vs 91K tokens), but auto mode intelligently avoided them. Struct was marginally better but not worth the overhead.</p>"},{"location":"concepts/#agon-vs-toon","title":"AGON vs TOON","text":"<p>AGON and TOON are complementary approaches to JSON encoding:</p> Aspect TOON AGON Philosophy \"One format for all JSON\" \"Best format for each shape, or JSON\" Approach Single unified format Multiple adaptive formats + fallback Risk Can be worse than JSON on irregular data Never worse than JSON Format Selection Always applies TOON encoding Auto-selects best or falls back to JSON Best For Uniform arrays, consistent pipelines Variable data shapes, risk-averse optimization Token Efficiency 40-60% savings on good matches 30-60% savings with safety guarantee"},{"location":"concepts/#when-they-produce-identical-output","title":"When They Produce Identical Output","text":"<p>For uniform arrays, <code>AGONText</code> and TOON produce near identical output:</p> TOON OutputAGON Text Output <pre><code>context:\ntask: Our favorite hikes together\nlocation: Boulder\nseason: spring_2025\nfriends[3]: ana,luis,sam\nhikes[3]{id,name,distanceKm,elevationGain,companion,wasSunny}:\n1,Blue Lake Trail,7.5,320,ana,true\n2,Ridge Overlook,9.2,540,luis,false\n3,Wildflower Loop,5.1,180,sam,true\n</code></pre> <pre><code>context:\ntask: Our favorite hikes together\nlocation: Boulder\nseason: spring_2025\nfriends[3]: ana luis    sam\nhikes[3]{id name    distanceKm  elevationGain   companion   wasSunny}\n1   Blue Lake Trail 7.5 320 ana true\n2   Ridge Overlook  9.2 540 luis    false\n3   Wildflower Loop 5.1 180 sam true\n</code></pre> <p>The only difference is AGONText uses the <code>\\t</code> delimiter</p> <p>Both: 96 tokens (+58.1% savings vs pretty JSON, +30.9% vs compact JSON)</p> <p>Choosing Between AGON and TOON</p> <p>Use TOON when:</p> <ul> <li>You have uniform, consistent data shapes</li> <li>You want a single predictable format</li> <li>You're comfortable with the risk of occasional inefficiency</li> </ul> <p>Use AGON when:</p> <ul> <li>Data shapes vary between requests</li> <li>You want guaranteed safety (never worse than JSON)</li> <li>You need format diversity (columnar, struct) for specific patterns</li> <li>You want adaptive selection without manual tuning</li> </ul>"},{"location":"concepts/#when-agon-helps-most","title":"When AGON Helps Most","text":"<p>AGON provides maximum value in these scenarios:</p> <ul> <li>Variable data pipelines where data shape changes between requests</li> <li>Uniform arrays with consistent fields (AGONText: 40-60% savings)</li> <li>Wide tables with 10+ columns (AGONColumns: 50-70% savings)</li> <li>Repeated nested patterns like market data with <code>{fmt, raw}</code> everywhere (AGONStruct: 30-50% savings)</li> <li>Cost-sensitive applications where every token counts</li> <li>Production LLM prompts needing reliability + token efficiency</li> <li>Mixed data types where different requests have different optimal formats</li> </ul>"},{"location":"concepts/#when-agon-helps-least","title":"When AGON Helps Least","text":"<p>AGON provides minimal value in these scenarios:</p> <ul> <li>Tiny payloads (&lt;50 tokens) where overhead exceeds savings</li> <li>Highly irregular objects with no repetition or consistent structure</li> <li>Single-use data with unpredictable, one-off structure</li> <li>Deeply nested heterogeneous data where no pattern emerges</li> <li>Already-optimized formats (if your data is already compact)</li> </ul> <p>When in doubt, use <code>format='auto'</code></p> <p>The safety guarantee means you can use auto mode everywhere. If specialized formats don't help, you'll get compact JSON\u2014no harm done.</p>"},{"location":"concepts/#next-steps","title":"Next Steps","text":""},{"location":"concepts/#api-reference","title":"API Reference","text":"<p>Detailed documentation of all methods and parameters</p>"},{"location":"concepts/#json-fallback","title":"JSON Fallback","text":"<p>View how JSON is used as a safety net</p>"},{"location":"concepts/#agontext-format","title":"AGONText Format","text":"<p>Complete guide to row-based encoding</p>"},{"location":"concepts/#benchmarks","title":"Benchmarks","text":"<p>Real-world token savings across 7 datasets</p>"},{"location":"formats/columns/","title":"AGONColumns Format","text":"<p>Columnar transpose encoding for wide tables\u2014optimized for 10+ fields per record.</p>"},{"location":"formats/columns/#overview","title":"Overview","text":"<p>AGONColumns is a columnar encoding format that transposes data to group values by field (column) instead of by record (row). This type clustering improves token efficiency for wide tables and numeric-heavy datasets.</p> <p>Best for:</p> <ul> <li>Wide tables (10+ fields per record)</li> <li>Employee records, financial data, analytics tables</li> <li>Numeric-heavy or homogeneous types per column</li> <li>Sparse data with many missing values</li> </ul> <p>Token efficiency: 50-70% savings vs pretty JSON, 20-40% vs compact JSON</p>"},{"location":"formats/columns/#basic-example","title":"Basic Example","text":"<p>Let's encode a simple employee table with 12 fields:</p> Input (JSON)Output (AGONColumns)Token Breakdown <pre><code>[\n  {\n    \"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\",\n    \"age\": 28, \"city\": \"NYC\", \"state\": \"NY\", \"zip\": \"10001\",\n    \"phone\": \"555-0001\", \"dept\": \"Eng\", \"title\": \"SWE\",\n    \"salary\": 120000, \"start_date\": \"2020-01-15\"\n  },\n  {\n    \"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\",\n    \"age\": 32, \"city\": \"SF\", \"state\": \"CA\", \"zip\": \"94105\",\n    \"phone\": \"555-0002\", \"dept\": \"Sales\", \"title\": \"Manager\",\n    \"salary\": 135000, \"start_date\": \"2019-03-20\"\n  },\n  {\n    \"id\": 3, \"name\": \"Charlie\", \"email\": \"charlie@example.com\",\n    \"age\": 25, \"city\": \"Austin\", \"state\": \"TX\", \"zip\": \"78701\",\n    \"phone\": \"555-0003\", \"dept\": \"Eng\", \"title\": \"SWE\",\n    \"salary\": 115000, \"start_date\": \"2021-07-10\"\n  }\n]\n</code></pre> <pre><code>[3]\n\u251c id: 1 2   3\n\u251c name: Alice   Bob Charlie\n\u251c email: alice@example.com  bob@example.com charlie@example.com\n\u251c age: 28   32  25\n\u251c city: NYC SF  Austin\n\u251c state: NY CA  TX\n\u251c zip: \"10001\"  \"94105\" \"78701\"\n\u251c phone: 555-0001   555-0002    555-0003\n\u251c dept: Eng Sales   Eng\n\u251c title: SWE    Manager SWE\n\u251c salary: 120000    135000  115000\n\u2514 start_date: 2020-01-15    2019-03-20  2021-07-10\n</code></pre> <p>Format elements:</p> <ul> <li><code>[3]</code> - Array length declaration</li> <li><code>\u251c</code> / <code>\u2514</code> - Tree characters (branch / last branch)</li> <li>Field names followed by tab-delimited values</li> <li>Last field uses <code>\u2514</code> to indicate end of structure</li> </ul> Format Tokens Savings Pretty JSON 309 baseline Compact JSON 190 +38.5% AGONText 137 +55.7% AGONColumns 158 +48.9% <p>Why columns helps: With 12 fields, grouping by type (all IDs together, all names together) provides better compression than row-based format. For even wider tables (20+ fields), the advantage increases.</p>"},{"location":"formats/columns/#format-specification","title":"Format Specification","text":""},{"location":"formats/columns/#syntax","title":"Syntax","text":"<pre><code>[count]\n\u251c field1: val1  val2    val3\n\u251c field2: val1  val2    val3\n\u2514 fieldN: val1  val2    val3\n</code></pre> <p>Components:</p> <ol> <li>Array length: <code>[N]</code> where N is the number of records</li> <li>Tree structure: <code>\u251c</code> for fields with siblings, <code>\u2514</code> for last field</li> <li>Field lines: <code>field: value1&lt;delimiter&gt;value2&lt;delimiter&gt;...</code></li> <li>Delimiters: Tab character (<code>\\t</code>) by default</li> </ol>"},{"location":"formats/columns/#tree-characters","title":"Tree Characters","text":"<p>Unicode (default):</p> <ul> <li><code>\u251c</code> (U+251C) - Branch: has more siblings below</li> <li><code>\u2514</code> (U+2514) - Last branch: final field</li> </ul> <p>ASCII mode:</p> <pre><code>from agon.formats import AGONColumns\n\n# Use ASCII tree characters for compatibility\nencoded = AGONColumns.encode(data, use_ascii=True)\n# Output:\n# [3]\n# | id: 1, 2, 3\n# | name: Alice, Bob, Charlie\n# ` email: ...\n</code></pre>"},{"location":"formats/columns/#delimiters","title":"Delimiters","text":"<p>Default: Tab character (<code>\\t</code>)</p> <p>Custom delimiter:</p> <pre><code>from agon.formats import AGONColumns\n\n# Use comma-space delimiter\nencoded = AGONColumns.encode(data, delimiter=\", \")\n\n# Output:\n# [3]\n# \u251c id: 1, 2, 3\n# \u251c name: Alice, Bob, Charlie\n# \u2514 email: alice@example.com, bob@example.com, charlie@example.com\n</code></pre>"},{"location":"formats/columns/#encoding-rules","title":"Encoding Rules","text":""},{"location":"formats/columns/#primitives","title":"Primitives","text":"<p>AGONColumns infers types from content\u2014no type markers needed:</p> Type Example Input Encoded Output String <code>\"Alice\"</code> <code>Alice</code> Integer <code>42</code> <code>42</code> Float <code>3.14</code> <code>3.14</code> Boolean <code>true</code> <code>true</code> Null <code>null</code> <code>null</code>"},{"location":"formats/columns/#missing-values","title":"Missing Values","text":"<p>Missing/null values in columns \u2192 Empty cell (consecutive delimiters):</p> <pre><code>[3]\n\u251c id: 1 2   3\n\u251c name: Alice   Bob Charlie\n\u2514 email: alice@example.com      charlie@example.com\n</code></pre> <p>Row 2 (Bob) has missing <code>email</code> field\u2014shown by consecutive tabs.</p> <p>Important distinction:</p> <ul> <li>Empty cell (``): field is absent from object</li> <li>Literal <code>null</code>: field is present with value <code>None</code></li> </ul> <pre><code>data = [\n    {\"id\": 1, \"name\": \"Alice\"},           # no email field\n    {\"id\": 2, \"name\": \"Bob\", \"email\": None}  # email field = null\n]\n\n# Encodes as:\n# [2]\n# \u251c id: 1   2\n# \u251c name: Alice Bob\n# \u2514 email:  null\n</code></pre>"},{"location":"formats/columns/#quoting","title":"Quoting","text":"<p>Simple values (no special characters) \u2192 Unquoted:</p> <pre><code>\u251c name: Alice   Bob Charlie\n</code></pre> <p>Values with spaces, delimiters, or special chars \u2192 Quoted:</p> <pre><code>\u251c address: \"123 Main St\"    \"456 Oak Ave\"   \"789 Pine Rd\"\n\u251c zip: \"10001\"  \"94105\" \"78701\"\n</code></pre> <p>Quotes in values \u2192 Escaped with backslash:</p> <pre><code>\u251c bio: \"Alice \\\"The Great\\\"\"    \"Bob \\\"Builder\\\"\"\n</code></pre>"},{"location":"formats/columns/#type-clustering-advantage","title":"Type Clustering Advantage","text":"<p>Columnar format groups same-type values together, improving LLM tokenization:</p> <p>Example: Numeric clustering</p> <pre><code>\u251c id: 1 2   3   4   5   6   7   8   9   10\n\u251c age: 28   32  25  45  38  29  41  33  27  36\n\u251c salary: 120000    135000  115000  150000  128000  122000  145000  132000  118000  140000\n</code></pre> <p>All numeric values are adjacent, creating better token compression than alternating between numbers and strings in row-based format.</p>"},{"location":"formats/columns/#nested-objects","title":"Nested Objects","text":"<p>Nested objects \u2192 Indented key-value pairs:</p> <pre><code>company:\n  name: Acme Corp\n  founded: 2010\n  headquarters:\n    city: San Francisco\n    state: CA\nemployees[3]\n\u251c id: 1 2   3\n\u251c name: Alice   Bob Charlie\n\u2514 dept: Eng Sales   Eng\n</code></pre>"},{"location":"formats/columns/#arrays","title":"Arrays","text":"<p>Primitive arrays \u2192 Inline with delimiter:</p> <pre><code>tags[5]: python javascript  rust    go  typescript\nscores[4]: 95   87  92  88\n</code></pre> <p>Object arrays \u2192 Columnar format (primary use case):</p> <pre><code>products[3]\n\u251c sku: A123 B456    C789\n\u251c name: Widget  Gadget  Gizmo\n\u2514 price: 9.99   19.99   29.99\n</code></pre>"},{"location":"formats/columns/#complete-example","title":"Complete Example","text":"<p>Real-world employee data:</p> Input (JSON)Output (AGONColumns)Token Comparison <pre><code>{\n  \"department\": \"Engineering\",\n  \"headcount\": 3,\n  \"employees\": [\n    {\n      \"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\",\n      \"age\": 28, \"city\": \"NYC\", \"state\": \"NY\", \"zip\": \"10001\",\n      \"phone\": \"555-0001\", \"dept\": \"Eng\", \"title\": \"SWE\",\n      \"salary\": 120000, \"start_date\": \"2020-01-15\"\n    },\n    {\n      \"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\",\n      \"age\": 32, \"city\": \"SF\", \"state\": \"CA\", \"zip\": \"94105\",\n      \"phone\": \"555-0002\", \"dept\": \"Sales\", \"title\": \"Manager\",\n      \"salary\": 135000, \"start_date\": \"2019-03-20\"\n    },\n    {\n      \"id\": 3, \"name\": \"Charlie\", \"email\": \"charlie@example.com\",\n      \"age\": 25, \"city\": \"Austin\", \"state\": \"TX\", \"zip\": \"78701\",\n      \"phone\": \"555-0003\", \"dept\": \"Eng\", \"title\": \"SWE\",\n      \"salary\": 115000, \"start_date\": \"2021-07-10\"\n    }\n  ]\n}\n</code></pre> <pre><code>department: Engineering\nheadcount: 3\nemployees[3]\n\u251c id: 1 2   3\n\u251c name: Alice   Bob Charlie\n\u251c email: alice@example.com  bob@example.com charlie@example.com\n\u251c age: 28   32  25\n\u251c city: NYC SF  Austin\n\u251c state: NY CA  TX\n\u251c zip: \"10001\"  \"94105\" \"78701\"\n\u251c phone: 555-0001   555-0002    555-0003\n\u251c dept: Eng Sales   Eng\n\u251c title: SWE    Manager SWE\n\u251c salary: 120000    135000  115000\n\u2514 start_date: 2020-01-15    2019-03-20  2021-07-10\n</code></pre> <p>| Format | Tokens | Savings | |--------|--------|---------| | Pretty JSON | 381 | baseline | | Compact JSON | 231 | +39.4% | | AGONText | 171 | +55.1% | | AGONColumns | 186 | +51.2% |</p> <p>Trade-off: AGONText wins for this example (fewer fields), but as field count grows beyond 10, AGONColumns pulls ahead due to type clustering.</p>"},{"location":"formats/columns/#when-agoncolumns-wins","title":"When AGONColumns Wins","text":"<ul> <li>Wide tables with 10+ fields per record (sweet spot: 15-50 fields)</li> <li>Financial data (many numeric columns: price, volume, market_cap, P/E, etc.)</li> <li>Analytics tables (metrics, dimensions, timestamps, aggregations)</li> <li>Employee databases (ID, name, email, age, city, state, zip, phone, dept, title, salary, etc.)</li> <li>Sparse data with many missing values (columnar handles better than row-based)</li> <li>Homogeneous column types (all numbers, all strings, etc.)</li> <li>Scientific datasets with measurement arrays (time, temp, pressure, velocity, etc.)</li> </ul>"},{"location":"formats/columns/#when-agoncolumns-loses","title":"When AGONColumns Loses","text":"<ul> <li>Few fields (2-5 fields) \u2192 AGONText wins with simpler row-based format</li> <li>Highly irregular structure (fields vary between records) \u2192 JSON fallback</li> <li>Deeply nested objects with no arrays \u2192 AGONStruct or JSON</li> <li>Heterogeneous data per column (mixed types) \u2192 Row-based better</li> <li>Very small arrays (&lt;3 records) \u2192 Overhead not worth it</li> </ul> <p>Example where Text wins:</p> <pre><code># Only 3 fields - too narrow for columnar advantage\nuser_data = [\n    {\"id\": 1, \"name\": \"Alice\", \"role\": \"admin\"},\n    {\"id\": 2, \"name\": \"Bob\", \"role\": \"user\"},\n    {\"id\": 3, \"name\": \"Charlie\", \"role\": \"user\"}\n]\n\nresult = AGON.encode(user_data, format=\"auto\")\n# \u2192 Selects \"text\" (simpler for narrow tables)\n</code></pre>"},{"location":"formats/columns/#direct-usage","title":"Direct Usage","text":"<p>For advanced use cases, use AGONColumns encoder directly:</p> <pre><code>from agon.formats import AGONColumns\n\n# Encode with default options\nencoded = AGONColumns.encode(data)\n\n# Custom delimiter (comma-space)\nencoded = AGONColumns.encode(data, delimiter=\", \")\n\n# ASCII tree characters (for compatibility)\nencoded = AGONColumns.encode(data, use_ascii=True)\n# Output uses | and ` instead of \u251c and \u2514\n\n# Without header (for LLM prompts)\nencoded = AGONColumns.encode(data, include_header=False)\n\n# With header (for decoding)\nencoded_with_header = AGONColumns.encode(data, include_header=True)\n# \u2192 @AGON columns\\n\\n[3]...\n\n# Decode\ndecoded = AGONColumns.decode(encoded)\nassert decoded == data  # Lossless\n</code></pre>"},{"location":"formats/columns/#edge-cases","title":"Edge Cases","text":"Empty array <pre><code>data = []\n\nresult = AGON.encode(data, format=\"columns\")\n# \u2192 [0]\n</code></pre> Single item array <pre><code>data = [{\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\"}]\n\nresult = AGON.encode(data, format=\"columns\")\n# \u2192 [1]\n#   \u251c id: 1\n#   \u251c name: Alice\n#   \u2514 email: alice@example.com\n</code></pre> All null values <pre><code>data = [{\"a\": None, \"b\": None}, {\"a\": None, \"b\": None}]\n\nresult = AGON.encode(data, format=\"columns\")\n# \u2192 [2]\n#   \u251c a: null   null\n#   \u2514 b: null   null\n</code></pre> Missing fields (sparse data) <pre><code>data = [\n    {\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n    {\"id\": 2, \"name\": \"Bob\"},  # no email\n    {\"id\": 3, \"name\": \"Charlie\", \"email\": \"charlie@example.com\"}\n]\n\nresult = AGON.encode(data, format=\"columns\")\n# \u2192 [3]\n#   \u251c id: 1 2   3\n#   \u251c name: Alice   Bob Charlie\n#   \u2514 email: alice@example.com      charlie@example.com\n</code></pre> <p>(Empty cell for Bob's missing email\u2014two consecutive tabs)</p> Special characters in column values <pre><code>data = [\n    {\"name\": \"Alice\\tSmith\", \"bio\": \"She said \\\"hi\\\"\"},\n    {\"name\": \"Bob\", \"bio\": \"Normal text\"}\n]\n\nresult = AGON.encode(data, format=\"columns\")\n# \u2192 [2]\n#   \u251c name: \"Alice\\tSmith\"  Bob\n#   \u2514 bio: \"She said \\\"hi\\\"\"    \"Normal text\"\n</code></pre> <p>(Automatic quoting and escaping)</p>"},{"location":"formats/columns/#comparison-columns-vs-text","title":"Comparison: Columns vs Text","text":"<p>For the same employee dataset with 12 fields:</p> AGONText (Row-Based)AGONColumns (Columnar) <pre><code>[3]{id  name    email   age city    state   zip phone   dept    title   salary  start_date}\n1   Alice   alice@example.com   28  NYC NY  \"10001\" 555-0001    Eng SWE 120000  2020-01-15\n2   Bob bob@example.com 32  SF  CA  \"94105\" 555-0002    Sales   Manager 135000  2019-03-20\n3   Charlie charlie@example.com 25  Austin  TX  \"78701\" 555-0003    Eng SWE 115000  2021-07-10\n</code></pre> <p>Tokens: 137 (better for this case\u201412 fields is borderline)</p> <pre><code>[3]\n\u251c id: 1 2   3\n\u251c name: Alice   Bob Charlie\n\u251c email: alice@example.com  bob@example.com charlie@example.com\n\u251c age: 28   32  25\n\u251c city: NYC SF  Austin\n\u251c state: NY CA  TX\n\u251c zip: \"10001\"  \"94105\" \"78701\"\n\u251c phone: 555-0001   555-0002    555-0003\n\u251c dept: Eng Sales   Eng\n\u251c title: SWE    Manager SWE\n\u251c salary: 120000    135000  115000\n\u2514 start_date: 2020-01-15    2019-03-20  2021-07-10\n</code></pre> <p>Tokens: 158 (slightly worse due to tree overhead, but scales better with more fields)</p> <p>Decision factors:</p> <ul> <li>2-10 fields: Use AGONText (simpler, less overhead)</li> <li>10-15 fields: Borderline\u2014auto mode chooses based on data</li> <li>15+ fields: Use AGONColumns (type clustering advantage wins)</li> </ul>"},{"location":"formats/columns/#faq","title":"FAQ","text":"When should I use Columns vs Text? <p>Use Columns when:</p> <ul> <li>10+ fields per record (sweet spot: 15-50 fields)</li> <li>Numeric-heavy data (financial, scientific)</li> <li>Sparse data with many nulls</li> </ul> <p>Use Text when:</p> <ul> <li>2-10 fields (simpler row-based format)</li> <li>Mixed data types per field</li> <li>Narrow tables</li> </ul> Can I customize tree characters? <p>Yes! Use ASCII mode for compatibility:</p> <pre><code>from agon.formats import AGONColumns\nencoded = AGONColumns.encode(data, use_ascii=True)\n# Uses | and ` instead of \u251c and \u2514\n</code></pre> How does AGONColumns handle missing fields? <p>Empty cells (consecutive delimiters) indicate missing fields:</p> <pre><code>data = [\n    {\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n    {\"id\": 2, \"name\": \"Bob\"},  # no email\n]\n\n# Encodes as:\n# [2]\n# \u251c id: 1   2\n# \u251c name: Alice Bob\n# \u2514 email: alice@example.com\n</code></pre> Why doesn't auto mode always choose Columns for wide tables? <p>Auto mode considers multiple factors:</p> <ul> <li>Token count: Columns must save \u2265 10% vs compact JSON</li> <li>Field count: 10+ fields favors Columns</li> <li>Type homogeneity: Mixed types reduce clustering benefit</li> <li>Data regularity: Irregular structure may favor JSON</li> </ul> <p>Use <code>force=True</code> to guarantee specialized format selection.</p>"},{"location":"formats/columns/#next-steps","title":"Next Steps","text":""},{"location":"formats/columns/#agontext-format","title":"AGONText Format","text":"<p>Learn about row-based encoding for narrow tables</p>"},{"location":"formats/columns/#agonstruct-format","title":"AGONStruct Format","text":"<p>Learn about template-based encoding</p>"},{"location":"formats/columns/#benchmarks","title":"Benchmarks","text":"<p>See AGONColumns performance on real datasets</p>"},{"location":"formats/columns/#api-reference","title":"API Reference","text":"<p>Complete API documentation</p>"},{"location":"formats/json/","title":"JSON Fallback","text":"<p>Understanding when and why AGON returns compact JSON.</p>"},{"location":"formats/json/#what-is-json-fallback","title":"What is JSON Fallback?","text":"<p>JSON fallback is AGON's safety mechanism\u2014when specialized formats (Text, Columns, Struct) don't provide sufficient token savings, auto mode returns compact JSON instead.</p> <p>This is a feature, not a failure. It's the guarantee that makes <code>format=\"auto\"</code> safe to use everywhere.</p>"},{"location":"formats/json/#when-json-fallback-occurs","title":"When JSON Fallback Occurs","text":"<p>Auto mode returns JSON when any of these conditions are met:</p> <ol> <li>Insufficient savings: Best specialized format saves less than <code>min_savings</code> threshold vs compact JSON</li> <li>Specialized formats worse: All specialized formats produce more tokens than compact JSON</li> <li>Explicit selection: User chooses <code>format=\"json\"</code></li> </ol> <pre><code># Auto mode with 10% minimum savings threshold\nresult = AGON.encode(data, format=\"auto\", min_savings=0.10)\n# Returns JSON if best format saves &lt;10% vs compact JSON\n</code></pre>"},{"location":"formats/json/#why-json-fallback-matters","title":"Why JSON Fallback Matters","text":"<p>Fixed-format encoders can make token counts worse than JSON on irregular data. AGON's fallback prevents this problem.</p>"},{"location":"formats/json/#the-fixed-format-problem","title":"The Fixed-Format Problem","text":"Without FallbackWith AGON Fallback <pre><code># Fixed format encoder - always applies format\nirregular_data = {\n    \"users\": [\n        {\"id\": 1, \"name\": \"Alice\"},\n        {\"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\", \"extra_field\": True}\n    ],\n    \"nested\": {\"deeply\": {\"nested\": {\"irregular\": \"structure\"}}}\n}\n\n# Fixed format struggles with irregular structure\nfixed_result = FixedEncoder.encode(irregular_data)\n# Might be worse than JSON! No safety net.\n</code></pre> <pre><code># AGON with safety guarantee\nresult = AGON.encode(irregular_data, format=\"auto\")\n\n# Auto mode tries specialized formats, finds they don't help\n# Returns compact JSON instead - guaranteed excellent savings\nprint(result.format)  # \u2192 \"json\"\n# Still gets ~35% savings vs pretty JSON!\n</code></pre>"},{"location":"formats/json/#when-json-wins-examples","title":"When JSON Wins: Examples","text":""},{"location":"formats/json/#1-highly-irregular-objects","title":"1. Highly Irregular Objects","text":"<p>Data with inconsistent structure:</p> <pre><code>data = [\n    {\"type\": \"user\", \"id\": 1, \"name\": \"Alice\"},\n    {\"type\": \"product\", \"sku\": \"ABC123\", \"price\": 29.99, \"inventory\": 50},\n    {\"type\": \"order\", \"order_id\": 1001, \"items\": [1, 2, 3], \"total\": 89.97}\n]\n\nresult = AGON.encode(data, format=\"auto\")\n# \u2192 \"json\" (no consistent structure to compress)\n</code></pre> <p>Why JSON wins: Specialized formats rely on repetition\u2014irregular data has no patterns to exploit.</p>"},{"location":"formats/json/#2-deeply-nested-heterogeneous-data","title":"2. Deeply Nested Heterogeneous Data","text":"<p>Complex nested structure with varied types:</p> <pre><code>data = {\n    \"config\": {\n        \"database\": {\"host\": \"localhost\", \"port\": 5432, \"ssl\": True},\n        \"cache\": {\"ttl\": 3600, \"max_size\": \"100MB\"},\n        \"features\": [\"auth\", \"logging\", \"metrics\"]\n    },\n    \"metadata\": {\n        \"version\": \"1.0.0\",\n        \"timestamp\": \"2025-01-15T10:30:00Z\"\n    }\n}\n\nresult = AGON.encode(data, format=\"auto\")\n# \u2192 \"json\" (nested objects vary in structure)\n</code></pre> <p>Why JSON wins: No repeated patterns, nesting doesn't follow consistent shape.</p>"},{"location":"formats/json/#3-small-payloads","title":"3. Small Payloads","text":"<p>Tiny data where format overhead exceeds savings:</p> <pre><code>data = {\"status\": \"ok\", \"count\": 42}\n\nresult = AGON.encode(data, format=\"auto\")\n# \u2192 \"json\" (payload too small for format overhead to pay off)\n</code></pre> <p>Why JSON wins: Compact JSON = 18 tokens, specialized format overhead \u2248 10 tokens\u2014not worth it.</p>"},{"location":"formats/json/#decision-matrix","title":"Decision Matrix","text":"<p>When should you expect JSON vs specialized formats?</p> Data Characteristic Expected Format Uniform array, 3-10 fields Text Uniform array, 10+ fields Columns Repeated nested <code>{a, b}</code> pattern (3+ times) Struct Mixed types, inconsistent structure JSON Deeply nested, heterogeneous JSON &lt;50 tokens total JSON Sparse data, many nulls Columns or JSON"},{"location":"formats/json/#faq","title":"FAQ","text":"Is JSON fallback a failure? <p>No! JSON fallback is a success\u2014it's the safety mechanism that guarantees you'll never do worse than compact JSON.</p> <p>When auto mode returns JSON, it means:</p> <ul> <li>Specialized formats didn't provide enough benefit</li> <li>You still get 30-40% savings vs pretty JSON</li> <li>You avoided complexity without sufficient reward</li> </ul> How do I force a specialized format? <p>Use <code>force=True</code> to disable JSON fallback:</p> <pre><code>result = AGON.encode(data, format=\"auto\", force=True)\n# Always uses best specialized format, never JSON\n</code></pre> <p>Warning: Only use when you've validated that specialized formats work well on your data.</p> Can I use a specific format directly? <p>Yes! Bypass auto mode entirely:</p> <pre><code># Guarantee Text format\nresult = AGON.encode(data, format=\"text\")\n\n# Guarantee Columns format\nresult = AGON.encode(data, format=\"columns\")\n\n# Guarantee Struct format\nresult = AGON.encode(data, format=\"struct\")\n</code></pre> Why does my data always return JSON? <p>Common reasons:</p> <ol> <li>Irregular structure - Specialized formats need consistent patterns</li> <li>Threshold too high - Try lowering <code>min_savings</code>:    <pre><code>result = AGON.encode(data, format=\"auto\", min_savings=0.05)\n</code></pre></li> <li>Data preparation - Ensure fields are consistent across records</li> <li>Genuinely unsuitable - Some data just doesn't compress well</li> </ol>"},{"location":"formats/json/#next-steps","title":"Next Steps","text":""},{"location":"formats/json/#agontext-format","title":"AGONText Format","text":"<p>Learn about the most common specialized format</p>"},{"location":"formats/json/#core-concepts","title":"Core Concepts","text":"<p>Design principles and adaptive approach</p>"},{"location":"formats/json/#api-reference","title":"API Reference","text":"<p>Complete API documentation</p>"},{"location":"formats/struct/","title":"AGONStruct Format","text":"<p>Template-based encoding for repeated nested patterns\u2014eliminates redundant field names.</p>"},{"location":"formats/struct/#overview","title":"Overview","text":"<p>AGONStruct is a template-based encoding format that defines reusable struct definitions for repeated object structures. Instead of repeating field names in every instance, you define the shape once and instantiate with just values.</p> <p>Best for:</p> <ul> <li>Repeated nested patterns (e.g., <code>{fmt, raw}</code> everywhere)</li> <li>Market data with formatted/raw value pairs</li> <li>Timestamps with values (<code>{time, value}</code>)</li> <li>3+ occurrences of the same 2+ field structure</li> </ul> <p>Token efficiency: 30-50% savings vs pretty JSON, 10-30% vs compact JSON (when pattern repeats \u22653 times)</p>"},{"location":"formats/struct/#basic-example","title":"Basic Example","text":"<p>Let's encode market data with a repeated <code>{fmt, raw}</code> pattern:</p> Input (JSON)Output (AGONStruct)Token Breakdown <pre><code>{\n  \"price\": {\"fmt\": \"$100.00\", \"raw\": 100.0},\n  \"change\": {\"fmt\": \"+5.00\", \"raw\": 5.0},\n  \"volume\": {\"fmt\": \"1.2M\", \"raw\": 1200000},\n  \"high\": {\"fmt\": \"$105.00\", \"raw\": 105.0},\n  \"low\": {\"fmt\": \"$98.50\", \"raw\": 98.5}\n}\n</code></pre> <pre><code>@FR: fmt, raw\n\nprice: FR($100.00, 100.0)\nchange: FR(+5.00, 5.0)\nvolume: FR(1.2M, 1200000)\nhigh: FR($105.00, 105.0)\nlow: FR($98.50, 98.5)\n</code></pre> <p>Format elements:</p> <ul> <li><code>@FR: fmt, raw</code> - Template definition (defines structure once)</li> <li><code>FR($100.00, 100.0)</code> - Instance (values only, no field names)</li> <li>5 instances share 1 template definition</li> </ul> Format Tokens Savings Pretty JSON 128 baseline Compact JSON 75 +41.4% AGONText 90 +29.7% AGONStruct 73 +43.0% <p>Why struct wins: The repeated <code>{fmt, raw}</code> pattern appears 5 times. Traditional formats repeat both field names (<code>\"fmt\"</code> and <code>\"raw\"</code>) in every instance. AGONStruct defines the template once, then each instance only contains values\u2014eliminating 10 redundant field name repetitions.</p>"},{"location":"formats/struct/#format-specification","title":"Format Specification","text":""},{"location":"formats/struct/#syntax","title":"Syntax","text":"<pre><code>@StructName: field1, field2, field3\n\nkey1: StructName(val1, val2, val3)\nkey2: StructName(val1, val2, val3)\n</code></pre> <p>Components:</p> <ol> <li>Template definition: <code>@StructName: field1, field2, ...</code></li> <li>Instance syntax: <code>StructName(value1, value2, ...)</code></li> <li>Inline usage: Can be used as values in key-value pairs or arrays</li> </ol>"},{"location":"formats/struct/#template-definitions","title":"Template Definitions","text":"<p>Basic template:</p> <pre><code>@FR: fmt, raw\n</code></pre> <p>Defines a struct named <code>FR</code> with two fields: <code>fmt</code> and <code>raw</code>.</p> <p>Optional fields:</p> <pre><code>@Point: x, y, z?\n</code></pre> <p>Field <code>z</code> is optional (marked with <code>?</code>). Instances can omit it.</p> <p>Struct inheritance:</p> <pre><code>@Timestamp: time, value\n@AggregatedMetric(Timestamp): count, sum\n</code></pre> <p><code>AggregatedMetric</code> inherits <code>time</code> and <code>value</code> from <code>Timestamp</code>, then adds <code>count</code> and <code>sum</code>.</p>"},{"location":"formats/struct/#instance-syntax","title":"Instance Syntax","text":"<p>Basic instance:</p> <pre><code>data = {\"price\": {\"fmt\": \"$100.00\", \"raw\": 100.0}}\n\n# Encodes as:\n# @FR: fmt, raw\n#\n# price: FR($100.00, 100.0)\n</code></pre> <p>Inline array of instances:</p> <pre><code>data = {\n    \"points\": [\n        {\"x\": 1, \"y\": 2},\n        {\"x\": 3, \"y\": 4},\n        {\"x\": 5, \"y\": 6}\n    ]\n}\n\n# Encodes as:\n# @Point: x, y\n#\n# points[3]: Point(1, 2), Point(3, 4), Point(5, 6)\n</code></pre> <p>Optional field instances:</p> <pre><code>data = [\n    {\"x\": 1, \"y\": 2, \"z\": 3},  # All fields\n    {\"x\": 4, \"y\": 5}            # Omit optional z\n]\n\n# Encodes as:\n# @Point: x, y, z?\n#\n# [2]: Point(1, 2, 3), Point(4, 5)\n</code></pre>"},{"location":"formats/struct/#encoding-rules","title":"Encoding Rules","text":""},{"location":"formats/struct/#automatic-template-detection","title":"Automatic Template Detection","text":"<p>AGONStruct automatically detects repeated object patterns with:</p> <ul> <li>Minimum occurrences: 3 (default, configurable)</li> <li>Minimum fields: 2 (default, configurable)</li> <li>Primitive values only: Nested objects/arrays don't create structs</li> </ul> <pre><code>from agon.formats import AGONStruct\n\n# Detect patterns with 5+ occurrences (more aggressive)\nencoded = AGONStruct.encode(data, min_occurrences=5)\n\n# Only create structs for 3+ field objects\nencoded = AGONStruct.encode(data, min_fields=3)\n</code></pre>"},{"location":"formats/struct/#template-naming","title":"Template Naming","text":"<p>Templates are named automatically based on field patterns:</p> Fields Generated Name Example <code>{fmt, raw}</code> <code>FR</code> <code>FR($100, 100.0)</code> <code>{x, y}</code> <code>Point</code> <code>Point(1, 2)</code> <code>{lat, lng}</code> <code>Coord</code> <code>Coord(37.7, -122.4)</code> <code>{min, max}</code> <code>Bounds</code> <code>Bounds(0, 100)</code> <code>{low, high}</code> <code>Range</code> <code>Range(50, 150)</code> <code>{a, b, c}</code> <code>ABC</code> <code>ABC(1, 2, 3)</code> Other <code>S</code>, <code>S1</code>, <code>S2</code> <code>S(v1, v2)</code>"},{"location":"formats/struct/#primitives-in-instances","title":"Primitives in Instances","text":"<p>Values in struct instances follow the same rules as other AGON formats:</p> Type Example Encoded in Instance String <code>\"Alice\"</code> <code>FR(Alice, 100)</code> Number <code>42</code> <code>FR(test, 42)</code> Boolean <code>true</code> <code>FR(flag, true)</code> Null <code>null</code> <code>FR(, 5)</code> (empty) With special chars <code>\"$100\"</code> <code>FR($100, 100)</code> <p>Quoting rules:</p> <ul> <li>Strings with commas, parens, or colons \u2192 Quoted</li> <li>Empty strings \u2192 <code>\"\"</code></li> <li>Most simple values \u2192 Unquoted</li> </ul> <pre><code>data = [\n    {\"name\": \"Alice, Bob\", \"count\": 5},  # Comma requires quoting\n    {\"name\": \"Charlie\", \"count\": 3}\n]\n\n# Encodes as:\n# @NC: name, count\n#\n# [2]: NC(\"Alice, Bob\", 5), NC(Charlie, 3)\n</code></pre>"},{"location":"formats/struct/#missing-values","title":"Missing Values","text":"<p>Optional fields can be omitted from instances:</p> <pre><code>data = [\n    {\"x\": 1, \"y\": 2, \"label\": \"A\"},\n    {\"x\": 3, \"y\": 4},  # No label\n    {\"x\": 5, \"y\": 6, \"label\": \"C\"}\n]\n\n# Encodes as:\n# @Point: x, y, label?\n#\n# [3]: Point(1, 2, A), Point(3, 4), Point(5, 6, C)\n</code></pre> <p>Null values are represented as empty cells:</p> <pre><code>data = [\n    {\"a\": 1, \"b\": 2},\n    {\"a\": 3, \"b\": None}  # Explicit null\n]\n\n# Encodes as:\n# @AB: a, b\n#\n# [2]: AB(1, 2), AB(3, )\n</code></pre>"},{"location":"formats/struct/#complete-example","title":"Complete Example","text":"<p>Real-world financial quote data:</p> Input (JSON)Output (AGONStruct)Token Comparison <pre><code>{\n  \"symbol\": \"AAPL\",\n  \"companyName\": \"Apple Inc.\",\n  \"regularMarketPrice\": {\"fmt\": \"150.00\", \"raw\": 150.0},\n  \"regularMarketChange\": {\"fmt\": \"+2.50\", \"raw\": 2.5},\n  \"regularMarketChangePercent\": {\"fmt\": \"+1.69%\", \"raw\": 0.0169},\n  \"regularMarketVolume\": {\"fmt\": \"52.3M\", \"raw\": 52300000},\n  \"marketCap\": {\"fmt\": \"2.45T\", \"raw\": 2450000000000},\n  \"fiftyTwoWeekHigh\": {\"fmt\": \"198.23\", \"raw\": 198.23},\n  \"fiftyTwoWeekLow\": {\"fmt\": \"124.17\", \"raw\": 124.17}\n}\n</code></pre> <pre><code>@FR: fmt, raw\n\nsymbol: AAPL\ncompanyName: Apple Inc.\nregularMarketPrice: FR(150.00, 150.0)\nregularMarketChange: FR(+2.50, 2.5)\nregularMarketChangePercent: FR(+1.69%, 0.0169)\nregularMarketVolume: FR(52.3M, 52300000)\nmarketCap: FR(2.45T, 2450000000000)\nfiftyTwoWeekHigh: FR(198.23, 198.23)\nfiftyTwoWeekLow: FR(124.17, 124.17)\n</code></pre> Format Tokens Savings Pretty JSON 285 baseline Compact JSON 167 +41.4% AGONText 197 +30.9% AGONStruct 153 +46.3% <p>Why struct wins: The <code>{fmt, raw}</code> pattern appears 7 times. Template definition costs ~10 tokens, but saves ~6 tokens per instance. At 7 instances, savings are <code>7 \u00d7 6 - 10 = 32 tokens</code>.</p>"},{"location":"formats/struct/#when-agonstruct-wins","title":"When AGONStruct Wins","text":"<ul> <li>Repeated nested patterns appearing 3+ times with same structure</li> <li>Market data with formatted/raw value pairs (<code>{fmt, raw}</code>)</li> <li>Time-series data with timestamp/value pairs (<code>{time, value}</code>)</li> <li>Coordinate data with x/y or lat/lng pairs (<code>{x, y}</code>, <code>{lat, lng}</code>)</li> <li>Range data with min/max or low/high pairs (<code>{min, max}</code>, <code>{low, high}</code>)</li> <li>API responses with consistent nested object shapes</li> <li>Scientific data with measurement/uncertainty pairs (<code>{value, error}</code>)</li> <li>Localization with locale/text pairs (<code>{lang, text}</code>)</li> </ul>"},{"location":"formats/struct/#when-agonstruct-loses","title":"When AGONStruct Loses","text":"<ul> <li>Few occurrences (&lt;3 instances) \u2192 Template overhead not worth it</li> <li>Few fields (1 field objects) \u2192 No savings from template</li> <li>Irregular nested structures \u2192 Can't identify consistent pattern</li> <li>Deeply nested objects \u2192 Struct only works for shallow primitives</li> <li>Array-heavy data \u2192 AGONText or AGONColumns better</li> </ul> <p>Example where template overhead hurts:</p> <pre><code># Only 2 instances - template not worth it\ndata = {\n    \"start\": {\"x\": 0, \"y\": 0},\n    \"end\": {\"x\": 100, \"y\": 50}\n}\n\nresult = AGON.encode(data, format=\"auto\")\n# \u2192 Selects \"json\" (template overhead exceeds savings)\n\n# Template would cost:\n# @Point: x, y  (~6 tokens)\n# But only saves ~4 tokens per instance\n# 2 instances \u00d7 4 - 6 = 2 net tokens saved (below 10% threshold)\n</code></pre>"},{"location":"formats/struct/#direct-usage","title":"Direct Usage","text":"<p>For advanced use cases, use AGONStruct encoder directly:</p> <pre><code>from agon.formats import AGONStruct\n\n# Encode with default options (min_occurrences=3, min_fields=2)\nencoded = AGONStruct.encode(data)\n\n# More aggressive: detect patterns with 5+ occurrences\nencoded = AGONStruct.encode(data, min_occurrences=5)\n\n# Only create structs for objects with 3+ fields\nencoded = AGONStruct.encode(data, min_fields=3)\n\n# Without header (for LLM prompts)\n# NOTE: Struct definitions are ALWAYS included even without header\n# (LLMs need templates to interpret instances)\nencoded = AGONStruct.encode(data, include_header=False)\n\n# With header (for decoding)\nencoded_with_header = AGONStruct.encode(data, include_header=True)\n# \u2192 @AGON struct\\n\\n@FR: fmt, raw\\n\\n...\n\n# Decode\ndecoded = AGONStruct.decode(encoded)\nassert decoded == data  # Lossless\n</code></pre>"},{"location":"formats/struct/#edge-cases","title":"Edge Cases","text":"Empty objects <pre><code>data = [\n    {\"a\": 1, \"b\": 2},\n    {},  # Empty object\n    {\"a\": 3, \"b\": 4}\n]\n\nresult = AGON.encode(data, format=\"struct\")\n# \u2192 [3]:\n#   - a: 1\n#     b: 2\n#   -\n#   - a: 3\n#     b: 4\n</code></pre> <p>(Empty object doesn't match any struct pattern)</p> Pattern appears only twice <pre><code>data = {\n    \"price\": {\"fmt\": \"$100\", \"raw\": 100.0},\n    \"change\": {\"fmt\": \"+5\", \"raw\": 5.0}\n}\n\nresult = AGON.encode(data, format=\"struct\")\n# No template created (default min_occurrences=3)\n# Falls back to inline objects:\n# price:\n#   fmt: $100\n#   raw: 100.0\n# change:\n#   fmt: +5\n#   raw: 5.0\n\n# OR force lower threshold:\nresult = AGON.encode(data, format=\"struct\", min_occurrences=2)\n# \u2192 @FR: fmt, raw\n#\n#   price: FR($100, 100.0)\n#   change: FR(+5, 5.0)\n</code></pre> Nested objects within structs <pre><code>data = [\n    {\"name\": \"Alice\", \"score\": 95, \"metadata\": {\"tag\": \"premium\"}},\n    {\"name\": \"Bob\", \"score\": 87, \"metadata\": {\"tag\": \"standard\"}}\n]\n\nresult = AGON.encode(data, format=\"struct\")\n# Struct only created for primitive fields (name, score)\n# Nested 'metadata' doesn't become part of struct\n</code></pre> Optional fields with mix of presence <pre><code>data = [\n    {\"x\": 1, \"y\": 2, \"z\": 3},\n    {\"x\": 4, \"y\": 5},\n    {\"x\": 6, \"y\": 7, \"z\": 9},\n    {\"x\": 8, \"y\": 10}\n]\n\nresult = AGON.encode(data, format=\"struct\")\n# \u2192 @Point: x, y, z?\n#\n#   [4]: Point(1, 2, 3), Point(4, 5), Point(6, 7, 9), Point(8, 10)\n</code></pre> <p>(Field <code>z</code> detected as optional\u2014present in some instances, absent in others)</p> Special characters in struct instance values <pre><code>data = [\n    {\"label\": \"Alice, Bob\", \"count\": 5},\n    {\"label\": \"Charlie (admin)\", \"count\": 3}\n]\n\nresult = AGON.encode(data, format=\"struct\")\n# \u2192 @LC: label, count\n#\n#   [2]: LC(\"Alice, Bob\", 5), LC(\"Charlie (admin)\", 3)\n</code></pre> <p>(Automatic quoting for special chars: commas, parens, colons)</p>"},{"location":"formats/struct/#token-efficiency-by-field-count","title":"Token Efficiency by Field Count","text":"<p>Scenario: 5 instances of same pattern</p> Fields Pattern Template Cost Per-Instance Savings Net Savings (5\u00d7) 2 <code>{a, b}</code> ~6 tokens ~4 tokens ~14 tokens 3 <code>{a, b, c}</code> ~10 tokens ~8 tokens ~30 tokens 4 <code>{a, b, c, d}</code> ~14 tokens ~12 tokens ~46 tokens 5 <code>{a, b, c, d, e}</code> ~18 tokens ~16 tokens ~62 tokens <p>Observation: More fields = greater per-instance savings. However, AGONStruct is optimized for small repeated patterns (2-4 fields). For 10+ field objects repeated many times, AGONColumns often wins.</p>"},{"location":"formats/struct/#comparison-struct-vs-text","title":"Comparison: Struct vs Text","text":"<p>For the same market data with 5 <code>{fmt, raw}</code> instances:</p> AGONText (No Template)AGONStruct (Template) <pre><code>price:\n  fmt: $100.00\n  raw: 100.0\nchange:\n  fmt: +5.00\n  raw: 5.0\nvolume:\n  fmt: 1.2M\n  raw: 1200000\nhigh:\n  fmt: $105.00\n  raw: 105.0\nlow:\n  fmt: $98.50\n  raw: 98.5\n</code></pre> <p>Tokens: 90 (each <code>fmt</code> and <code>raw</code> field name repeated 5 times)</p> <pre><code>@FR: fmt, raw\n\nprice: FR($100.00, 100.0)\nchange: FR(+5.00, 5.0)\nvolume: FR(1.2M, 1200000)\nhigh: FR($105.00, 105.0)\nlow: FR($98.50, 98.5)\n</code></pre> <p>Tokens: 73 (<code>fmt</code> and <code>raw</code> defined once in template, eliminated from instances)</p> <p>Key difference: AGONText repeats field names in every nested object. AGONStruct defines template once, then instances reference it by name with positional values.</p>"},{"location":"formats/struct/#faq","title":"FAQ","text":"When should I use Struct vs Text/Columns? <p>Use Struct when:</p> <ul> <li>Same nested object pattern repeats 3+ times</li> <li>Objects have 2-4 primitive fields</li> <li>Examples: <code>{fmt, raw}</code>, <code>{x, y}</code>, <code>{time, value}</code></li> </ul> <p>Use Text when:</p> <ul> <li>Flat uniform arrays (no nested patterns)</li> <li>2-10 fields per record</li> </ul> <p>Use Columns when:</p> <ul> <li>Wide tables (10+ fields)</li> <li>Numeric-heavy data</li> </ul> Can I customize minimum occurrences threshold? <p>Yes! Use the encoder directly:</p> <pre><code>from agon.formats import AGONStruct\n\n# Lower threshold (detect patterns with 2+ occurrences)\nencoded = AGONStruct.encode(data, min_occurrences=2)\n\n# Higher threshold (only create templates for very common patterns)\nencoded = AGONStruct.encode(data, min_occurrences=10)\n</code></pre> How does AGONStruct handle deeply nested objects? <p>AGONStruct only creates templates for shallow objects with primitive values. Nested objects and arrays within structs are encoded recursively but don't become part of the struct template:</p> <pre><code>data = [\n    {\n        \"name\": \"Alice\",\n        \"score\": 95,\n        \"metadata\": {\"tag\": \"premium\", \"region\": \"US\"}\n    },\n    {\"name\": \"Bob\", \"score\": 87, \"metadata\": {\"tag\": \"standard\"}}\n]\n\n# Template only created for name/score (primitives)\n# 'metadata' remains nested, not part of struct\n</code></pre> Can struct templates inherit from other templates? <p>Yes, using inheritance syntax:</p> <pre><code>@Base: field1, field2\n@Extended(Base): field3, field4\n</code></pre> <p><code>Extended</code> inherits <code>field1</code> and <code>field2</code> from <code>Base</code>, then adds its own fields. However, this feature is rarely needed\u2014auto-detection typically creates independent templates.</p> Why doesn't auto mode always choose Struct for nested data? <p>Auto mode considers multiple factors:</p> <ul> <li>Occurrence count: Pattern must repeat \u2265 3 times (default)</li> <li>Field count: Objects must have \u2265 2 fields</li> <li>Token savings: Must save \u2265 10% vs compact JSON</li> <li>Pattern regularity: All instances must have same fields (with optional variations)</li> </ul> <p>If no repeated pattern meets these criteria, auto mode falls back to JSON or uses Text/Columns for arrays.</p>"},{"location":"formats/struct/#next-steps","title":"Next Steps","text":""},{"location":"formats/struct/#agontext-format","title":"AGONText Format","text":"<p>Learn about row-based encoding for flat arrays</p>"},{"location":"formats/struct/#agoncolumns-format","title":"AGONColumns Format","text":"<p>Learn about columnar encoding for wide tables</p>"},{"location":"formats/struct/#benchmarks","title":"Benchmarks","text":"<p>See AGONStruct performance on real datasets</p>"},{"location":"formats/struct/#api-reference","title":"API Reference","text":"<p>Complete API documentation</p>"},{"location":"formats/text/","title":"AGONText Format","text":"<p>Row-based tabular encoding for uniform arrays\u2014AGON's most commonly selected format.</p>"},{"location":"formats/text/#overview","title":"Overview","text":"<p>AGONText is a row-based encoding format optimized for uniform arrays of objects with consistent field structure. It's similar to TOON's approach and produces identical output for uniform arrays.</p> <p>Best for:</p> <ul> <li>User lists, transaction logs, simple metrics</li> <li>Consistent field structure across records (2-10 fields)</li> <li>Flat or shallow nesting</li> <li>Homogeneous data types per field</li> </ul>"},{"location":"formats/text/#basic-example","title":"Basic Example","text":"<p>Let's encode a simple user list:</p> Input (JSON)Output (AGONText)Token Breakdown <pre><code>[\n  {\"id\": 1, \"name\": \"Alice\", \"role\": \"admin\"},\n  {\"id\": 2, \"name\": \"Bob\", \"role\": \"user\"},\n  {\"id\": 3, \"name\": \"Charlie\", \"role\": \"user\"}\n]\n</code></pre> <pre><code>[3]{id  name    role}\n1   Alice   admin\n2   Bob user\n3   Charlie user\n</code></pre> <p>Format elements:</p> <ul> <li><code>[3]</code> - Array length declaration</li> <li><code>{id name role}</code> - Field headers (tab-separated)</li> <li>Rows - Tab-delimited values</li> </ul> Element Tokens Purpose <code>[3]</code> 2 Array length (enables validation) <code>{id name role}</code> 5 Field headers (schema) Row 1 5 <code>1 Alice admin</code> Row 2 4 <code>2 Bob user</code> Row 3 5 <code>3 Charlie user</code> Total 26 58% savings vs pretty JSON (62 tokens) <p>Why it works: Eliminates repeated field names (<code>\"id\":</code>, <code>\"name\":</code>, <code>\"role\":</code>) and JSON syntax overhead (<code>{</code>, <code>}</code>, <code>\"</code>).</p>"},{"location":"formats/text/#format-specification","title":"Format Specification","text":""},{"location":"formats/text/#syntax","title":"Syntax","text":"<pre><code>[count]{field1  field2  field3}\nvalue1  value2  value3\nvalue1  value2  value3\n</code></pre> <p>Components:</p> <ol> <li>Array length: <code>[N]</code> where N is the number of records</li> <li>Field headers: <code>{field1 field2 ...}</code> tab-separated field names</li> <li>Rows: Tab-delimited values, one row per record</li> </ol>"},{"location":"formats/text/#delimiters","title":"Delimiters","text":"<p>Default: Tab character (<code>\\t</code>)</p> <p>Custom delimiter:</p> <pre><code>from agon.formats import AGONText\n\n# Use pipe delimiter instead of tab\nencoded = AGONText.encode(data, delimiter=\"|\")\n</code></pre>"},{"location":"formats/text/#encoding-rules","title":"Encoding Rules","text":""},{"location":"formats/text/#primitives","title":"Primitives","text":"<p>AGONText infers types from content\u2014no type markers needed:</p> Type Example Input Encoded Output String <code>\"Alice\"</code> <code>Alice</code> Integer <code>42</code> <code>42</code> Float <code>3.14</code> <code>3.14</code> Boolean <code>true</code> <code>true</code> Null <code>null</code> `` (empty cell)"},{"location":"formats/text/#missing-values","title":"Missing Values","text":"<p>Missing/null values \u2192 Empty cell (consecutive delimiters):</p> <pre><code>[2]{id  name    email}\n1   Alice   alice@example.com\n2   Bob\n</code></pre> <p>Row 2 has empty <code>email</code> field (two consecutive tabs).</p>"},{"location":"formats/text/#quoting","title":"Quoting","text":"<p>Simple values (no special characters) \u2192 Unquoted:</p> <pre><code>Alice   Bob Charlie\n</code></pre> <p>Values with spaces, tabs, or newlines \u2192 Quoted:</p> <pre><code>\"Alice Smith\"   \"Bob\\tJones\"    Charlie\n</code></pre> <p>Quotes in values \u2192 Escaped with backslash:</p> <pre><code>\"Alice \\\"The Great\\\"\"\n</code></pre>"},{"location":"formats/text/#nested-objects","title":"Nested Objects","text":"<p>Nested objects \u2192 Indented key-value pairs:</p> <pre><code>context:\n  task: Our favorite hikes\n  location: Boulder\n  season: spring_2025\nfriends[3]: ana luis    sam\n</code></pre> <p>Indentation: 2 spaces per level</p>"},{"location":"formats/text/#arrays","title":"Arrays","text":"<p>Primitive arrays \u2192 Inline with delimiter:</p> <pre><code>friends[3]: ana luis    sam\nscores[4]: 95   87  92  88\n</code></pre> <p>Object arrays \u2192 Tabular format (primary use case):</p> <pre><code>hikes[3]{id name    distanceKm}\n1   Blue Lake Trail 7.5\n2   Ridge Overlook  9.2\n3   Wildflower Loop 5.1\n</code></pre>"},{"location":"formats/text/#complete-example","title":"Complete Example","text":"<p>Real-world data from <code>toon.json</code>:</p> Input (JSON)Output (AGONText)Token Comparison <pre><code>{\n  \"context\": {\n    \"task\": \"Our favorite hikes together\",\n    \"location\": \"Boulder\",\n    \"season\": \"spring_2025\"\n  },\n  \"friends\": [\"ana\", \"luis\", \"sam\"],\n  \"hikes\": [\n    {\n      \"id\": 1,\n      \"name\": \"Blue Lake Trail\",\n      \"distanceKm\": 7.5,\n      \"elevationGain\": 320,\n      \"companion\": \"ana\",\n      \"wasSunny\": true\n    },\n    {\n      \"id\": 2,\n      \"name\": \"Ridge Overlook\",\n      \"distanceKm\": 9.2,\n      \"elevationGain\": 540,\n      \"companion\": \"luis\",\n      \"wasSunny\": false\n    },\n    {\n      \"id\": 3,\n      \"name\": \"Wildflower Loop\",\n      \"distanceKm\": 5.1,\n      \"elevationGain\": 180,\n      \"companion\": \"sam\",\n      \"wasSunny\": true\n    }\n  ]\n}\n</code></pre> <pre><code>context:\n  task: Our favorite hikes together\n  location: Boulder\n  season: spring_2025\nfriends[3]: ana luis    sam\nhikes[3]{id name    distanceKm  elevationGain   companion   wasSunny}\n1   Blue Lake Trail 7.5 320 ana true\n2   Ridge Overlook  9.2 540 luis    false\n3   Wildflower Loop 5.1 180 sam true\n</code></pre> Format Tokens Savings Pretty JSON 229 baseline Compact JSON 139 +39.3% AGONText 96 +58.1% <p>30.9% savings vs compact JSON!</p>"},{"location":"formats/text/#when-agontext-wins","title":"When AGONText Wins","text":"<ul> <li>Uniform arrays with 3+ records having identical field structure</li> <li>Consistent field types (all records have same fields with same types)</li> <li>2-10 fields per record (sweet spot for row-based format)</li> <li>Simple data types (strings, numbers, booleans\u2014not deeply nested objects)</li> <li>Transaction logs (timestamp, user, action, status)</li> <li>User lists (id, name, email, role)</li> <li>Metrics/analytics (date, metric_name, value, unit)</li> <li>Flat CSV-like data being sent to LLMs</li> </ul>"},{"location":"formats/text/#when-agontext-loses","title":"When AGONText Loses","text":"<ul> <li>Wide tables (10+ fields) \u2192 AGONColumns wins (type clustering)</li> <li>Irregular structure (fields vary between records) \u2192 JSON fallback</li> <li>Deeply nested objects with no arrays \u2192 JSON or Struct</li> <li>Sparse data (many nulls) \u2192 AGONColumns handles better</li> <li>Repeated nested patterns (e.g., <code>{fmt, raw}</code> everywhere) \u2192 Struct wins</li> </ul> <p>Example where Columns wins:</p> <pre><code># 12 fields - wide table\nemployee_data = [\n    {\n        \"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\",\n        \"age\": 28, \"city\": \"NYC\", \"state\": \"NY\", \"zip\": \"10001\",\n        \"phone\": \"555-0001\", \"dept\": \"Eng\", \"title\": \"SWE\",\n        \"salary\": 120000, \"start_date\": \"2020-01-15\"\n    },\n    # ... more records\n]\n\nresult = AGON.encode(employee_data, format=\"auto\")\n# \u2192 Selects \"columns\" (better type clustering for 12 fields)\n</code></pre>"},{"location":"formats/text/#direct-usage","title":"Direct Usage","text":"<p>For advanced use cases, use AGONText encoder directly:</p> <pre><code>from agon.formats import AGONText\n\n# Encode with default options\nencoded = AGONText.encode(data)\n\n# Custom delimiter\nencoded = AGONText.encode(data, delimiter=\"|\")\n\n# Without header (for LLM prompts)\nencoded = AGONText.encode(data, include_header=False)\n\n# With header (for decoding)\nencoded_with_header = AGONText.encode(data, include_header=True)\n# \u2192 @AGON text\\n\\n[3]{id...}\n\n# Decode\ndecoded = AGONText.decode(encoded)\nassert decoded == data  # Lossless\n</code></pre>"},{"location":"formats/text/#edge-cases","title":"Edge Cases","text":"Empty array <pre><code>data = []\n\nresult = AGON.encode(data, format=\"text\")\n# \u2192 [0]{}\n</code></pre> Single item array <pre><code>data = [{\"id\": 1, \"name\": \"Alice\"}]\n\nresult = AGON.encode(data, format=\"text\")\n# \u2192 [1]{id  name}\n#   1   Alice\n</code></pre> All null values <pre><code>data = [{\"a\": None, \"b\": None}]\n\nresult = AGON.encode(data, format=\"text\")\n# \u2192 [1]{a   b}\n#\n</code></pre> <p>(Two consecutive tabs for empty cells)</p> Special characters in values <pre><code>data = [{\"name\": \"Alice\\tBob\", \"quote\": \"He said \\\"hi\\\"\"}]\n\nresult = AGON.encode(data, format=\"text\")\n# \u2192 [1]{name    quote}\n#   \"Alice\\tBob\"    \"He said \\\"hi\\\"\"\n</code></pre> <p>(Automatic quoting and escaping)</p>"},{"location":"formats/text/#comparison-with-toon","title":"Comparison with TOON","text":"<p>For uniform arrays, AGONText and TOON produce near identical output:</p> JSONTOONAGONText <pre><code>[\n  {\"id\": 1, \"name\": \"Alice\", \"role\": \"admin\"},\n  {\"id\": 2, \"name\": \"Bob\", \"role\": \"user\"},\n  {\"id\": 3, \"name\": \"Charlie\", \"role\": \"user\"}\n]\n</code></pre> <pre><code>[3]{id,name,role}:\n1,Alice,admin\n2,Bob,user\n3,Charlie,user\n</code></pre> <pre><code>[3]{id  name    role}\n1   Alice   admin\n2   Bob user\n3   Charlie user\n</code></pre> <p>Both achieve the same token savings vs JSON.</p> <p>TOON and AGONText are near identical! The only difference is AGONText uses the <code>\\t</code> delimiter.</p>"},{"location":"formats/text/#faq","title":"FAQ","text":"When should I use Text vs Columns? <p>Use Text when:</p> <ul> <li>2-10 fields per record</li> <li>Consistent structure</li> <li>Mixed data types</li> </ul> <p>Use Columns when:</p> <ul> <li>10+ fields (wide tables)</li> <li>Numeric-heavy data</li> <li>Sparse data (many nulls)</li> </ul> Can I customize the delimiter? <p>Yes! Use AGONText encoder directly:</p> <pre><code>from agon.formats import AGONText\nencoded = AGONText.encode(data, delimiter=\"|\")\n</code></pre> Does AGONText handle nested objects? <p>Yes, with indentation:</p> <pre><code>data = {\"user\": {\"name\": \"Alice\", \"age\": 28}}\n\n# Encodes as:\n# user:\n#   name: Alice\n#   age: 28\n</code></pre> Is AGONText the same as TOON? <p>For uniform arrays: Yes, near identical output.</p> <p>Overall: AGON includes safety features (auto mode, JSON fallback) that TOON doesn't have.</p>"},{"location":"formats/text/#next-steps","title":"Next Steps","text":""},{"location":"formats/text/#agoncolumns-format","title":"AGONColumns Format","text":"<p>Learn about columnar encoding for wide tables</p>"},{"location":"formats/text/#agonstruct-format","title":"AGONStruct Format","text":"<p>Learn about template-based encoding</p>"},{"location":"formats/text/#benchmarks","title":"Benchmarks","text":"<p>See AGONText performance on real datasets</p>"},{"location":"formats/text/#api-reference","title":"API Reference","text":"<p>Complete API documentation</p>"}]}